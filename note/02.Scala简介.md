## Scala特性
- *面向对象*：Scala是一种纯粹的面向对象语言。一个对象的类型和行为是由类和特征来描述的。类通过子类化和基于灵活的混合类来进行扩展，作为多重继承的一个可靠性解决方案。
- *函数式编程:* Scala提供了-个轻量级语法来定义匿名函数，它也支持高阶函数，允许函数嵌套，并支持柯里化。Scala 的case class与其内置的Pattern Matching模型支持函数式编程语言中的代数类型。Singleton 对象提供了-一种方便的方法来组合不属于类的函数。用户还可以使用Scala的模式匹配，编写类似正则表达式的代码来处理XML数据。
- *静态类型*  Scala配备了一种表现型的系统，它以静态的方式进行抽象，以安全和连贯的方式进行使用。系统支持通用类、内部类、抽象类和复合类作为对象成员，也支持隐式参数、转换和多态方法等。这些功能为安全重用抽象编程和软件的类型安全扩展提供了强大的支持。
- *Scala是可扩展的* 在实践中，专用领域的应用程序开发往往需要该领域特定的语言扩展。Scala 提供了许多独特语言机制，可以以库的形式轻易无缝添加新的语言结构。
## 数据类型：
- 和Java不同的是，除了这些数据类型首字母需要大写外，在Scala中，这些类型都是“类”，并且都是scala包的成员，比如，Int的全名是scala.Int。对于字符串，Scala用java.lang.String类来表示字符串。
- Scala会区分不同类型的值，并且会基于使用值的方式来确定其类型，这称为类型推断。Scala经常会使用类型推断来确定混合使用类型情况下所表示的类型，例如，在加法中混用Int和Double类型时，Scala会确定其结果值是Double类型
1. Int类型：
	-  Int类型对应的变量是整型变量，变量对应的是整型数据。Int类型变量的定义包括十六进制和十进制定义法，而八进制定义法从Scala 2.10版本开始已经取消。     
	- ` //十六进制定义法 scala>val x=0x29x：Int =41//十进制定义法scala>val y=41y：Int =41`
2. Float类型：
	-   Float类型表示的是浮点数。如果直接输入一个浮点数，Scala编译器会自动进行类型推导，并自动解释成Double类型，所以需要在浮点数后加F或f才能定义Float类型的变量。
3. Double类型：
	-  Double数据类型表示的是双精度的浮点数。Double类型变量的定义如代码所示。
	- 双精度浮点类型的变量还可以采用指数表示法，浮点数后加E或e均可
4. Char类型：
	- Char数据类型表示的是字符类型，用单引号' '将字符包裹起来。
	- 部分特殊字符如双引号、换行符及反斜杠等的定义需要加转义符“\”或者使用对应的Unicode编码
5. String类型：
	- String数据类型表示的是字符串类型，用双引号" "将字符串包裹起来。
	- 如果字符串类型中有双引号，则需要使用转义符“\”
6. Boolean类型：
	- Boolean数据类型表示的是布尔类型，包括true和false。
## 变量与常量
- 使用关键词 "var" 声明变量`Var VariableName:DataType = InitialValue`
- 使用关键词 "val" 声明常量。`Val VariableName:DataType = InitialValue `
- val类似于Java里的final变量。一旦初始化了，val就不能再被赋值。
- var如同Java里面的非final变量，可以在它的声明周期中被多次赋值。
- 尽管var变量可以重新赋值，但是不能改变它的类型，所以不能将一个变量重新赋值为与定义类型不兼容的数据。例如，定义一个类型为Int的变量，并为其赋一个String值，会导致编译错误
- 如果定义一个类型为Double的var变量，可以再为其赋一个Int类型的值，因为Int类型可以自动转换为Double类型。
*惰性变量：* lazy 惰性变量指使用lazy关键字来修饰的变量，经过lazy关键字修饰的变量只有在真正使用时才会被赋值。而且lazy关键字只能修饰val类型的变量，而不能修饰var类型的变量。
```Scala
scala>lazy val TestString = "hello,Scala"
TestString:String=<lazy>
//经过lazy关键字修饰的变量在定义时不被赋值
scala>TestString
res0:String = hello Scala
//在使用时，变量才会赋值
```
**lazy关键字不能用于var类型变量主要是为了避免程序运行过程中变量未使用便被重新赋值**
***命名规范：*** Scala中的变量命名可以使用字母、数字和一些特殊的操作字符。因此可以使用标准算术运算符(例如 * 和+)和常量(例如π和ф)取代比较长的命名，从而使代码更有表述性。结合字母、数字和字符构成Scala合法标识符的规则如下：
- 一个字母后跟有0个或多个字母和数字，如a123、aa123等。
- 一个字母后跟有0个或者多个字母和数字，接着是一个下划线“_ ” ，后面是一个或多个字母和数字或者是一个或多个操作符,如a_1、a_b、a1_ * 等。
- 一个或多个操作符，如+、* 、 -、/等。
- 一个或者多个除反引号外的任意字符，这些字符被包含在一对反引号中，如a.b是错误命名，而加上反引号的`` `a.b` ``是正确的。
- Scala中有些保留字，不能用作标识符，但是反引号括起来除外，如return是保留字，变量名return是非法的，但`` `return` ``是合法的。保留字一般可以通过查询保留字表得出，往往是常用的有特定含义的单词，如case、else等。
![Pasted image 20231031124100](https://github.com/HDZ12/Scala/assets/99587726/575541c8-eb7c-405b-8153-9e9c6226e3ac)
## 表达式
Scala中基本数据类型的操作主要包括算术运算操作、关系运算操作和逻辑运算操作
- 算术运算操作:在Scala中，可以使用加(+)、减(-) 、乘(* ) 、除(/) 、取余（%）等操作符，而且，这些操作符相当于方法。以加法为例，例如，5 + 3和(5).+(3)是等价的，即 a 方法 b  与  a.方法(b) 这二者是等价的。前者是后者的简写形式，这里的+是方法名，是Int类中的一个方法。在Scala中并没有提供++和--操作符，当需要递增或递减时，可以采用如下代码所示方式表达。
`Scala>var i = 5,Scala>i+=1` 
Scala语言还提供了用+、-符号来表示正负数，并且这两个符号可以直接在操作中使用，例如：
- 关系运算操作: Scala的关系运算操作包括大于(>)、小于(<)、大于等于(>=)和小于等于(<=)等，会产生Boolean类型的结果。
- 逻辑运算操作：逻辑运算操作包括逻辑与(&&)及逻辑或(||)，逻辑与操作为真时必须保证两个变量同时为真，而逻辑或操作为真时只要求至少一个变量为真。
![1698727563697](https://github.com/HDZ12/Scala/assets/99587726/cd8e6f6c-cf7c-4682-bc76-e411d83050a6)
![1698727587954](https://github.com/HDZ12/Scala/assets/99587726/ee23a14f-1ccf-4bc7-bed2-d6fe44f97eca)
![1698727673009](https://github.com/HDZ12/Scala/assets/99587726/fbc00e5a-04b0-4507-bb98-a25e049c9b71)
## Range操作
```Scala
//1.创建一个从1到5的数值序列，包含区间终点5，步长为1。
scala>1 to 5 or scala> 1.to(5)
//2.创建一个从1到5的数值序列，不包含区间终点5，步长为1。
scala>1 until 5
//3.创建一个从1到10的数值序列，包含区间终点10，步长为2。 
scala> 1 to 10 by 2 //(int)
scala> 1L to 10L by 2//(long)
scala> BigInt(1) to BigInt(10) by 2//(BigInt)
//创建一个从10到1的数值序列，包含区间终点1，步长为-2。
scala> 10 to 1 by -2
//5.创建一个Char类型的数值序列，从'a'到'g'，步长为3。
scala>'a' to 'g' by 3
//6.创建一个浮点类型的数值序列，从0.5f到5.9f，步长为0.8f。
scala> 0.5f to 5.9f by 0.8f//(Float)
scala> 0.5 to 5.9 by 0.8//(Double)
scala> BigDecimal(0.5) to BigDecimal(5.9) by 0.8//(BigDecimal)
```

## 数组
- 数组为有序的相同类型的元素的集合，在Scala中数组是最常用、最重要的数据结构。Scala中的数组分为定长数组和变长数组，定长数组在定义时长度被确定，在运行时数组长度不会发生变化，而变长数组内存空间长度会随着程序运行的需要而动态扩容
- 定长数组（Array）：Scala 语言中提供的Array数组是用来存储固定大小的同类型元素，数组长度在定义时被确定，数组占有的内存空间在程序运行时不会被改变。数组中某个指定的元素是通过索引来访问的，数组的第一个元素索引为0，最后一个元素的索引为元素总数减1。`scala>var str:Array=new Array[Int](3)`
- 字符串等非数值对象类型在数组定义时若没有赋值，将会被初始化为null，而数值型数组在数组定义时未显性赋值，则被初始化为0。
- 变长数组（ArrayBuffer）：变长数组在程序运行过程中，其数组长度可以随程序运行的需要而增加。最常用的变长数组为ArrayBuffer,它在包scala.collection.mutable中，在使用时需要显式地引入
- 定义多维数组：多维数组一个数组中的值可以是另一个数组，另一个数组的值也可以是一个数组。![Pasted image 20231031153544](https://github.com/HDZ12/Scala/assets/99587726/3f9d7bd7-6652-4c4f-976d-823e073fdb78)
- Scala提供了一个用于创建多维数组的ofDim方法`scala>var myMatrix = Array.ofDim[Int](num1, num2)
  - 操作数组![1698737935981](https://github.com/HDZ12/Scala/assets/99587726/b0df13f8-5480-4aad-9038-a511824be9c5)
   - 数组常用的方法:下表中为 Scala 语言中处理数组的重要方法，使用前需要使用 import Array._ 引入包![1698737982998](https://github.com/HDZ12/Scala/assets/99587726/a5a545c2-b742-4e3d-84f5-79ee7649329d)
 ## 函数
- 一个标准的函数定义需要以下几部分：第一，使用def关键字进行函数声明；第二，需要定义函数名、函数参数以及返回值类型；第三，需要函数体。
- 定义函数：![Pasted image 20231031154105](https://github.com/HDZ12/Scala/assets/99587726/00334a76-e4f0-4465-a1e2-a5f6ac13fbaf)
-   Scala具有类型推导功能，会根据最终的返回值推导函数的返回值类型，因此在实际应用中也常常会省略函数的返回值类型。
		- 推导限制：
			- 如果需要return关键字指定返回值，则必须显示地指定函数返回值的类型。
			- 如果函数中存在递归调用且使用return关键字，则必须显示地指定函数返回值的类型。
- 
- 字面量 ：字面量包括整数字面量、浮点数字面量、布尔型字面量、字符字面量、字符串字面量、符号字面量、函数字面量和元组字面量
- 匿名函数：匿名函数即是在定义函数的时候不给出函数名。匿名函数是使用箭头“=>”定义的，箭头的左边是参数列表，箭头右边是表达式，表达式将产生函数的结果。
	- 调用匿名函数可以将函数赋值给一个常量或变量，然后通过常量名或变量名调用该函数`scala>val=addInt(x:Int,y:Int)=>x+y,scala>addInt(1,2)`
- 
- 占位符语法：当函数的每个参数在函数字面量内仅出现一次，可以省略“=>”并用下划线“ _ ”作为参数的占位符来简化函数字面量的表示，第一个下划线代表第一个参数，第二个下划线代表第二个参数，依此类推
 `val counter=(value:Int)=>value+1 `=`val counter=(_:Int)+1`
 
- 高阶函数：高阶函数就是操作其他函数的函数。高阶函数可以使用函数作为参数，也可以使用函数作为输出结果。
	- `def sum(x:Int,y:Int)=x+y` `def addInt(f:(Int,Int)=>Int,a:Int,b:Int)=f(a,b)`
	- 占位符法调用高阶函数
		- `def combination(x:Int,y:Int,f:(Int,Int)=>Int)=f(x,y)`
		- `combination(23,12,_*_)`
- 递归函数：递归函数意味着函数可以调用它本身
	- 尾递归是指递归调用是函数的最后一个语句，而且其结果被直接返回。 由于递归结果总是直接返回，尾递归比较方便转换为循环，因此编译器容易对它进行优化。
- 柯里化:柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数






